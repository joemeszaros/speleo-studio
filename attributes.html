<!doctype html>
<!--
Copyright 2024 Joe Meszaros

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Speleo Studio</title>
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        margin: 0;
        padding: 20px;
        background-color: #f5f5f5;
        color: #333;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 30px;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 20px;
      }

      .header-logo {
        width: 160px;
        height: 160px;
        background: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      }

      .header-logo img {
        width: 140px;
        height: 140px;
      }

      .header-content h1 {
        margin: 0;
        font-size: 2.5em;
        font-weight: 300;
      }

      .header-content p {
        margin: 10px 0 0 0;
        opacity: 0.9;
        font-size: 1.1em;
      }

      .content {
        padding: 30px;
      }

      .category {
        margin-bottom: 40px;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        overflow: hidden;
      }

      .category-header {
        background: #f8f9fa;
        padding: 20px;
        border-bottom: 1px solid #e0e0e0;
      }

      .category-title {
        font-size: 1.5em;
        font-weight: 600;
        color: #2c3e50;
        margin: 0;
        text-transform: capitalize;
      }

      .category-id {
        color: #7f8c8d;
        font-size: 0.9em;
        margin-top: 5px;
      }

      .attributes-list {
        padding: 20px;
      }

      .attribute {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 4px;
        margin-bottom: 12px;
        overflow: hidden;
      }

      .attribute-header {
        background: #e9ecef;
        padding: 8px 12px;
        border-bottom: 1px solid #dee2e6;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .attribute-name {
        font-size: 1em;
        font-weight: 600;
        color: #495057;
        margin: 0;
        text-transform: capitalize;
      }

      .attribute-id {
        color: #6c757d;
        font-size: 0.8em;
        background: #fff;
        padding: 2px 6px;
        border-radius: 3px;
      }

      .attribute-description {
        color: #6c757d;
        font-size: 0.85em;
        font-style: italic;
        margin-top: 4px;
        padding: 4px 8px;
        background: #f8f9fa;
        border-radius: 3px;
        border-left: 3px solid #007bff;
      }

      .attribute-params {
        padding: 8px 12px;
      }

      .param {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 3px;
        margin-bottom: 6px;
        padding: 6px 8px;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .param-name {
        font-weight: 600;
        color: #495057;
        font-size: 0.9em;
      }

      .param-description {
        color: #6c757d;
        font-size: 0.8em;
        font-style: italic;
        margin-top: 2px;
        margin-bottom: 4px;
        padding: 2px 6px;
        background: #f8f9fa;
        border-radius: 3px;
        border-left: 2px solid #28a745;
        flex-basis: 100%;
      }

      .search-section {
        background: #f8f9fa;
        padding: 20px;
        border-bottom: 1px solid #e9ecef;
      }

      .search-container {
        position: relative;
        max-width: 600px;
        margin: 0 auto;
      }

      #search-input {
        width: 100%;
        padding: 12px 40px 12px 16px;
        border: 2px solid #ddd;
        border-radius: 25px;
        font-size: 16px;
        outline: none;
        transition: border-color 0.3s ease;
        box-sizing: border-box;
      }

      #search-input:focus {
        border-color: #667eea;
      }

      #clear-search {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        font-size: 20px;
        color: #999;
        cursor: pointer;
        padding: 0;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: background-color 0.2s ease;
      }

      #clear-search:hover {
        background-color: #f0f0f0;
        color: #666;
      }

      .search-info {
        text-align: center;
        margin-top: 10px;
        font-size: 14px;
        color: #666;
      }

      .hidden {
        display: none !important;
      }

      .search-highlight {
        background-color: #fff3cd;
        padding: 2px 4px;
        border-radius: 3px;
      }

      .category-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
        user-select: none;
        transition: background-color 0.2s ease;
      }

      .category-header:hover {
        background-color: #f8f9fa;
      }

      .category-toggle {
        background: none;
        border: none;
        font-size: 18px;
        color: #6c757d;
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 4px;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
      }

      .category-toggle:hover {
        background-color: #e9ecef;
        color: #495057;
      }

      .category-toggle.collapsed {
        transform: rotate(-90deg);
      }

      .category-content {
        transition: all 0.3s ease;
        overflow: hidden;
      }

      .category-content.collapsed {
        max-height: 0;
        opacity: 0;
        margin-top: 0;
      }

      .category-content.expanded {
        max-height: none;
        opacity: 1;
      }

      .category-title-section {
        flex: 1;
      }

      .param-details {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      .param-detail {
        background: #f8f9fa;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.8em;
        white-space: nowrap;
      }

      .param-detail strong {
        color: #495057;
      }

      .required {
        background: #d4edda;
        border-color: #c3e6cb;
      }

      .required .param-name::after {
        content: ' *';
        color: #dc3545;
        font-weight: bold;
      }

      .type-string {
        color: #007bff;
      }
      .type-int {
        color: #28a745;
      }
      .type-float {
        color: #fd7e14;
      }

      .values-list {
        background: #e3f2fd;
        border: 1px solid #bbdefb;
        border-radius: 3px;
        padding: 2px 6px;
        font-size: 0.8em;
      }

      .values-list strong {
        color: #1976d2;
      }

      .validators {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 3px;
        padding: 2px 6px;
        font-size: 0.8em;
        white-space: nowrap;
      }

      .validators strong {
        color: #856404;
      }

      .stats {
        background: #e9ecef;
        padding: 20px;
        border-radius: 6px;
        margin-bottom: 30px;
      }

      .stats h3 {
        margin: 0 0 15px 0;
        color: #495057;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
      }

      .stat-item {
        text-align: center;
        background: white;
        padding: 15px;
        border-radius: 4px;
        border: 1px solid #dee2e6;
      }

      .stat-number {
        font-size: 2em;
        font-weight: bold;
        color: #007bff;
        margin-bottom: 5px;
      }

      .stat-label {
        color: #6c757d;
        font-size: 0.9em;
      }

      .no-params {
        color: #6c757d;
        font-style: italic;
        padding: 20px;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="header-logo">
          <img src="images/logo.png" alt="Speleo Studio Logo" />
        </div>
        <div class="header-content">
          <h1>Speleo Studio</h1>
          <p data-i18n="attributes.title">Attribute Definitions Reference</p>
        </div>
      </div>

      <div class="search-section">
        <div class="search-container">
          <input
            type="text"
            id="search-input"
            data-i18n-placeholder="attributes.search.placeholder"
            placeholder="Search categories, attributes, or parameters..."
          />
          <button id="clear-search" data-i18n-title="attributes.search.clearButton" title="Clear search">×</button>
        </div>
        <div class="search-info">
          <span id="search-results-info"></span>
        </div>
      </div>

      <div class="content">
        <div class="stats">
          <h3 data-i18n="attributes.overview">Overview</h3>
          <div class="stats-grid">
            <div class="stat-item">
              <div class="stat-number" id="total-categories"></div>
              <div class="stat-label" data-i18n="attributes.cats">Categories</div>
            </div>
            <div class="stat-item">
              <div class="stat-number" id="total-attributes"></div>
              <div class="stat-label" data-i18n="attributes.attributes">Attributes</div>
            </div>
            <div class="stat-item">
              <div class="stat-number" id="total-params"></div>
              <div class="stat-label" data-i18n="attributes.parameters">Parameters</div>
            </div>
          </div>
        </div>

        <div id="categories-container">
          <!-- Categories will be populated by JavaScript -->
        </div>
      </div>
    </div>

    <script type="module">
      // Import i18n library
      import { i18n } from './src/i18n/i18n.js';
      import { AttributesDefinitions } from './src/attributes.js';

      // Wait for i18n to be ready
      await i18n.init();

      // Apply translations to elements with data-i18n attributes
      function applyTranslations() {
        const elements = document.querySelectorAll('[data-i18n]');
        elements.forEach((element) => {
          const key = element.getAttribute('data-i18n');
          element.textContent = i18n.t(key);
        });

        // Apply placeholder and title translations
        const placeholderElements = document.querySelectorAll('[data-i18n-placeholder]');
        placeholderElements.forEach((element) => {
          const key = element.getAttribute('data-i18n-placeholder');
          element.placeholder = i18n.t(key);
        });

        const titleElements = document.querySelectorAll('[data-i18n-title]');
        titleElements.forEach((element) => {
          const key = element.getAttribute('data-i18n-title');
          element.title = i18n.t(key);
        });
      }

      // Apply translations
      applyTranslations();

      // Load attributes from JSON file
      async function loadAttributes(url = 'attributes.json') {
        console.log(`Loading attributes from ${url}`);
        const response = await fetch(url);
        return await response.json();
      }

      // Initialize the page
      loadAttributes()
        .then((attributesData) => {
          console.log(`Attributes definitions loaded: ${attributesData.version}`);
          attributesData.definitions = AttributesDefinitions.resolveReferences(attributesData);
          currentAttributesData = attributesData; // Store for search functionality
          updateStats(attributesData);
          renderAttributes(attributesData);
        })
        .catch((error) => {
          console.error('Failed to load attributes:', error);
          document.getElementById('categories-container').innerHTML =
            '<div class="no-params">Failed to load attributes definitions</div>';
        });

      function updateStats(attributesData) {
        // Calculate total categories
        const totalCategories = attributesData.categories.length;

        // Calculate total attributes
        const totalAttributes = attributesData.definitions.length;

        // Calculate total parameters across all attributes
        const totalParameters = attributesData.definitions.reduce((total, attr) => {
          return total + Object.keys(attr.params || {}).length;
        }, 0);

        // Update the DOM elements
        document.getElementById('total-categories').textContent = totalCategories;
        document.getElementById('total-attributes').textContent = totalAttributes;
        document.getElementById('total-params').textContent = totalParameters;
      }

      function renderAttributes(attributesData) {
        const container = document.getElementById('categories-container');

        // Group attributes by category
        const attributesByCategory = {};
        attributesData.definitions.forEach((attr) => {
          if (!attributesByCategory[attr.category]) {
            attributesByCategory[attr.category] = [];
          }
          attributesByCategory[attr.category].push(attr);
        });

        // Render each category
        attributesData.categories.forEach((category) => {
          const categoryAttributes = attributesByCategory[category.id] || [];

          const categoryDiv = document.createElement('div');
          categoryDiv.className = 'category';

          categoryDiv.innerHTML = `
                     <div class="category-header" onclick="toggleCategory('${category.id}')">
                         <div class="category-title-section">
                             <h2 class="category-title">${i18n.t(`attributes.categories.${category.name}`) || category.name}</h2>
                             <div class="category-id">${i18n.t('attributes.categoryId')}: ${category.id}</div>
                         </div>
                         <button class="category-toggle" id="toggle-${category.id}">▼</button>
                     </div>
                     <div class="category-content expanded" id="content-${category.id}">
                         <div class="attributes-list">
                             ${
                               categoryAttributes.length > 0
                                 ? categoryAttributes.map((attr) => renderAttribute(attr)).join('')
                                 : `<div class="no-params">${i18n.t('attributes.noAttributes')}</div>`
                             }
                         </div>
                     </div>
                 `;

          container.appendChild(categoryDiv);
        });
      }

      function renderAttribute(attribute) {
        const params = Object.keys(attribute.params || {});

        const attributeDescriptionKey = `attributes.namesDescription.${attribute.name}`;
        const attributeDescription = i18n.t(attributeDescriptionKey, {}, undefined, false);
        const hasAttributeDescription = attributeDescription && attributeDescription !== attributeDescriptionKey;
        return `
                 <div class="attribute">
                     <div class="attribute-header">
                         <h3 class="attribute-name">${i18n.t(`attributes.names.${attribute.name}`) || attribute.name}</h3>
                         <div class="attribute-id">${i18n.t('attributes.attributeId')}: ${attribute.id}</div>
                     </div>
                     ${hasAttributeDescription ? `<div class="attribute-description">${attributeDescription}</div>` : ''}
                     <div class="attribute-params">
                         ${
                           params.length > 0
                             ? params.map((paramName) => renderParam(paramName, attribute.params[paramName])).join('')
                             : `<div class="no-params">${i18n.t('attributes.noParameters')}</div>`
                         }
                     </div>
                 </div>
             `;
      }

      function renderParam(paramName, paramDef) {
        const isRequired = paramDef.required || false;
        const typeClass = `type-${paramDef.type}`;

        let validatorsHtml = '';
        if (paramDef.validators) {
          const validatorItems = Object.entries(paramDef.validators)
            .map(([key, value]) => `${key}: ${value}`)
            .join(', ');
          validatorsHtml = `<span class="validators"><strong>${i18n.t('attributes.validators')}:</strong> ${validatorItems}</span>`;
        }

        let valuesHtml = '';
        if (paramDef.values) {
          const valuesList = paramDef.values.map((v) => `"${i18n.t(`attributes.values.${v}`) || v}"`).join(', ');
          valuesHtml = `<span class="values-list"><strong>${i18n.t('attributes.valuesLabel')}:</strong> ${valuesList}</span>`;
        }

        const paramDescriptionKey = `attributes.paramsDescription.${paramName}`;
        const paramDescription = i18n.t(paramDescriptionKey, {}, undefined, false);
        const hasParamDescription = paramDescription && paramDescription !== paramDescriptionKey;
        return `
                 <div class="param ${isRequired ? 'required' : ''}">
                     <div class="param-name">${i18n.t(`attributes.params.${paramName}`) || paramName}</div>
                     ${hasParamDescription ? `<div class="param-description">${paramDescription}</div>` : ''}
                     <div class="param-details">
                         <span class="param-detail">
                             <strong>${i18n.t('attributes.type')}:</strong> <span class="${typeClass}">${paramDef.type}</span>
                         </span>
                         ${isRequired ? `<span class="param-detail"><strong>${i18n.t('attributes.required')}:</strong> ${i18n.t('attributes.yes')}</span>` : ''}
                         ${validatorsHtml}
                         ${valuesHtml}
                     </div>
                 </div>
             `;
      }

      // Search functionality
      let currentAttributesData = null;
      let filteredData = null;

      function setupSearch() {
        const searchInput = document.getElementById('search-input');
        const clearButton = document.getElementById('clear-search');
        const searchInfo = document.getElementById('search-results-info');

        searchInput.addEventListener('input', handleSearch);
        clearButton.addEventListener('click', clearSearch);

        function handleSearch() {
          const query = searchInput.value.toLowerCase().trim();

          if (!query) {
            clearSearch();
            return;
          }

          if (!currentAttributesData) return;

          filteredData = filterAttributes(currentAttributesData, query);
          renderFilteredAttributes(filteredData);
          updateSearchInfo(query, filteredData);
        }

        function clearSearch() {
          searchInput.value = '';
          if (currentAttributesData) {
            renderAttributes(currentAttributesData);
            updateStats(currentAttributesData);
          }
          searchInfo.textContent = '';
        }

        function filterAttributes(data, query) {
          // Filter individual attributes from definitions array
          const filteredDefinitions = data.definitions.filter((attribute) => {
            const attributeName = i18n.t(`attributes.names.${attribute.name}`) || attribute.name;
            const attributeMatches = attributeName.toLowerCase().includes(query);

            const paramNameMatches = Object.keys(attribute.params || {}).some((paramName) => {
              const paramNameTranslated = i18n.t(`attributes.params.${paramName}`) || paramName;
              return paramNameTranslated.toLowerCase().includes(query);
            });

            const paramValuesMatches = Object.values(attribute.params || {}).some((x) => {
              return (x?.values ?? []).some((value) => {
                const paramValueTranslated = i18n.t(`attributes.values.${value}`) || value;
                return paramValueTranslated.toLowerCase().includes(query);
              });
            });

            return attributeMatches || paramNameMatches || paramValuesMatches;
          });

          // Group filtered attributes by category
          const attributesByCategory = {};
          filteredDefinitions.forEach((attr) => {
            if (!attributesByCategory[attr.category]) {
              attributesByCategory[attr.category] = [];
            }
            attributesByCategory[attr.category].push(attr);
          });

          // Create filtered categories with their attributes
          const filteredCategories = data.categories
            .filter((category) => {
              const categoryName =
                i18n.t(`attributes.categories.${category.name}`, {}, undefined, false) || category.name;
              const categoryMatches = categoryName.toLowerCase().includes(query);
              const hasMatchingAttributes =
                attributesByCategory[category.id] && attributesByCategory[category.id].length > 0;

              return categoryMatches || hasMatchingAttributes;
            })
            .map((category) => {
              const categoryName =
                i18n.t(`attributes.categories.${category.name}`, {}, undefined, false) || category.name;
              const categoryMatches = categoryName.toLowerCase().includes(query);

              // If category name matches, show ALL attributes in that category
              // If only attributes match, show only the matching attributes
              const attributesToShow = categoryMatches
                ? data.definitions.filter((attr) => attr.category === category.id)
                : attributesByCategory[category.id] || [];

              return {
                ...category,
                attributes: attributesToShow
              };
            });

          return { categories: filteredCategories, definitions: filteredDefinitions };
        }

        function renderFilteredAttributes(data) {
          const container = document.getElementById('categories-container');
          container.innerHTML = '';

          // Render each filtered category
          data.categories.forEach((category) => {
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'category';

            categoryDiv.innerHTML = `
              <div class="category-header" onclick="toggleCategory('${category.id}')">
                <div class="category-title-section">
                  <h2 class="category-title">${i18n.t(`attributes.categories.${category.name}`, {}, undefined, false) || category.name}</h2>
                  <div class="category-id">${i18n.t('attributes.categoryId')}: ${category.id}</div>
                </div>
                <button class="category-toggle" id="toggle-${category.id}">▼</button>
              </div>
              <div class="category-content expanded" id="content-${category.id}">
                <div class="attributes-list">
                  ${
                    category.attributes && category.attributes.length > 0
                      ? category.attributes.map((attr) => renderAttribute(attr)).join('')
                      : `<div class="no-params">${i18n.t('attributes.noAttributes')}</div>`
                  }
                </div>
              </div>
            `;

            container.appendChild(categoryDiv);
          });
        }

        function updateSearchInfo(query, data) {
          const totalCategories = data.categories.length;
          const totalAttributes = data.categories.reduce((sum, cat) => sum + cat.attributes.length, 0);
          const totalParameters = data.categories.reduce(
            (sum, cat) =>
              sum + cat.attributes.reduce((attrSum, attr) => attrSum + Object.keys(attr.params || {}).length, 0),
            0
          );

          const resultsFor = i18n.t('attributes.search.resultsFor');
          const resultsSummary = i18n.t('attributes.search.resultsSummary');
          const [categoriesLabel, attributesLabel, parametersLabel] = resultsSummary.split(', ');

          searchInfo.innerHTML = `
            <strong>${resultsFor} "${query}":</strong> 
            ${totalCategories} ${categoriesLabel}, ${totalAttributes} ${attributesLabel}, ${totalParameters} ${parametersLabel}
          `;
        }
      }

      // Initialize search when page loads
      setupSearch();

      // Global function to toggle category visibility
      window.toggleCategory = function (categoryId) {
        const toggleButton = document.getElementById(`toggle-${categoryId}`);
        const content = document.getElementById(`content-${categoryId}`);

        if (content.classList.contains('collapsed')) {
          // Expand
          content.classList.remove('collapsed');
          content.classList.add('expanded');
          toggleButton.textContent = '▼';
          toggleButton.classList.remove('collapsed');
        } else {
          // Collapse
          content.classList.remove('expanded');
          content.classList.add('collapsed');
          toggleButton.textContent = '▶';
          toggleButton.classList.add('collapsed');
        }
      };
    </script>
  </body>
</html>
